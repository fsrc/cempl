// Generated by CoffeeScript 1.10.0
(function() {
  var _, elements, ensureMarkupArguments, markup, unwrapFunctionToString,
    slice = [].slice;

  _ = require('lodash');

  elements = ['a', 'abbr', 'acronym', 'efines ', 'address', 'applet', 'efines ', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'pecifies ', 'bdi', 'bdo', 'big', 'efines ', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'efines ', 'cite', 'code', 'col', 'colgroup', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'efines ', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'efines ', 'footer', 'form', 'frame', 'efines ', 'frameset', 'efines ', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noframes', 'efines ', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'efines ', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'efines', 'u', 'ul', 'var', 'video', 'wbr', 'h1', 'h2', 'h3', 'h4', 'h5'];


  /* unwrapFunctionToString()
   * purpose: convert function into string that can
   *          be sent over to client side
   *
   * in:      function
   * out:     string with code within the function
   */

  unwrapFunctionToString = function(fn) {
    return _(fn.toString()).split('\n').initial().tail().map(_.trim).join("").replace(/^return\s/, "");
  };


  /* ensureMarkupArguments()
   * purpose: helper function to the markup() function that
   *          ensures that the arguments sent in to markup()
   *          is correct
   * in:      tag     - name of tag
   *          attr    - attribute object
   *          content - either a function or a string
   * out:     [tag, attr, f, text] - array of the correct arguments
   */

  ensureMarkupArguments = function(tag, attr, content) {
    var f, text;
    f = null;
    text = null;
    if (!_.isString(tag)) {
      throw "Tag must be a string";
    }
    if (_.isPlainObject(attr)) {
      attr = attr;
    } else if ((_.isString(attr) || _.isFunction(attr)) && _.isUndefined(content)) {
      content = attr;
      attr = null;
    } else {
      throw "Attributes must be plain objects and content must be string or function";
    }
    if (_.isFunction(content)) {
      f = content;
    } else if (_.isString(content)) {
      text = content;
    }
    return [tag, attr, f, text];
  };


  /* markup()
   * purpose: represents a node in the html tree
   * in:      intag - the name of the tag to represent
   *          inattr - the attributes to go with the tag (plain object)
   *          incontent - the content to be wrapped by the tag
   * out:     the wrapper object, which contains functions that
   *          can be executed upon the tag
   */

  markup = function(intag, inattr, incontent) {
    var attr, f, ref, tag, text;
    ref = ensureMarkupArguments(intag, inattr, incontent), tag = ref[0], attr = ref[1], f = ref[2], text = ref[3];
    return (function(tag, attr, f, text) {
      var all, children, outer, tagfn, wrapper;
      children = [];

      /* tagfn()
       * purpose: it's called whenever a tag is executed, for instance
       *          @body or @tag('mytag'). the arguments is passed on
       *          to the markup() function, and the result of the
       *          markup() function is pushed on to the children array
       * in:      args... - any arguments that the markup() function
       *          would allow
       * out:     the current wrapper
       */
      tagfn = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        children.push(markup.apply(null, args));
        return wrapper;
      };
      all = _.reduce(elements, function(obj, name) {
        obj[name] = _.bind(tagfn, null, name);
        return obj;
      }, {});
      wrapper = {

        /* apply()
         * purpose: enables the generator to be extended with
         *          predefined functions. the result will be mixed in
         *          on the same level as other siblings
         * in:      f - function that should be mixed in
         *          args... - any arguments that the function takes
         * out:     unknown
         */
        apply: function() {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _.bind.apply(_, [f, wrapper].concat(slice.call(args)))();
        },

        /* tag()
         * purpose: enables the programmer to use an arbitrary tag
         *          by passing the first parameter tag as the name
         *          of the tag. for more info look at tagfn()
         */
        tag: tagfn,

        /* text()
         * purpose: allows user to insert any string within the tag
         * in:      text - the string to be inserted
         * out:     unknown
         */
        text: function(text) {
          return children.push({
            "eval": function() {
              return text;
            }
          });
        },

        /* doctype()
         * purpose: be able to set doc type
         * in:      attr - the string to accompany the doctype tag
         *          for simplicity, this defaults to "html" as of
         *          html5 standard
         * out:     unknown
         */
        doctype: function(attr) {
          return children.push({
            "eval": function() {
              if (_.isUndefined(attr)) {
                attr = "html";
              }
              return "<!DOCTYPE " + attr + ">";
            }
          });
        },

        /* script()
         * purpose: allows the user to define a script tag. this is
         *          an exception to the other default tags because
         *          it can take a function as an argument. the function
         *          will be stringified, unwrapped and sent to the
         *          client as a string within the script tag
         * in:      attr - any tag attributes
         *          content - function that will be stringified and unwrapped
         *          and sent to the client within the script tag or string
         *          that will be sent within the script tag
         * out:     unknown
         */
        script: function(scrattr, scrcontent) {
          if (_.isPlainObject(scrattr)) {
            scrattr = scrattr;
          } else if ((_.isFunction(scrattr) || _.isString(scrattr)) && _.isUndefined(scrcontent)) {
            scrcontent = scrattr;
            scrattr = null;
          } else {
            throw "Script tag attributes must be plain object";
          }
          if (_.isFunction(scrcontent)) {
            scrcontent = unwrapFunctionToString(scrcontent);
          } else if (_.isString(scrcontent)) {
            scrcontent = scrcontent;
          } else if (_.isUndefined(scrcontent)) {
            scrcontent = "";
          } else {
            throw "Script tag scrcontent must be either a string or a function";
          }
          return children.push({
            "eval": function() {
              var attribs;
              attribs = "";
              if (scrattr) {
                attribs = " " + _.map(scrattr, function(v, k) {
                  return k + "='" + v + "'";
                }).join(' ');
              }
              return "<script" + attribs + ">" + scrcontent + "</script>";
            }
          });
        }
      };
      outer = {

        /* before()
         * purpose: insert element in position before this tag
         */
        before: function(f) {
          throw "Not implemented";
        },

        /* before()
         * purpose: insert element in position after this tag
         */
        after: function(f) {
          throw "Not implemented";
        },
        "eval": function() {
          var attribs, inner;
          if (text != null) {
            inner = text;
          } else {
            inner = _.map(children, function(child) {
              return child["eval"]();
            }).join("");
          }
          attribs = "";
          if (attr != null) {
            attribs = " " + _.map(attr, function(v, k) {
              return k + "='" + v + "'";
            }).join(' ');
          }
          if (tag === "root_cempl_document") {
            return inner;
          } else if (tag != null) {
            return "<" + tag + attribs + ">" + inner + "</" + tag + ">";
          } else {
            return inner;
          }
        }
      };
      wrapper = _.assign(wrapper, all);
      if (f != null) {
        _.bind(f, wrapper)();
      }
      return outer;
    })(tag, attr, f, text);
  };

  module.exports = function(f) {
    return markup('root_cempl_document', f);
  };

}).call(this);
