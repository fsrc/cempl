// Generated by CoffeeScript 1.9.0
(function() {
  var attrStr, elements, ensureMarkupArguments, getRootFrame, indentation, markup, printTagStack, textStr, unwrapFunctionToString, _,
    __slice = [].slice;

  _ = require('lodash');

  elements = ['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'h1', 'h2', 'h3', 'h4', 'h5'];

  indentation = function(level) {
    var _i, _results;
    return _.reduce((function() {
      _results = [];
      for (var _i = 0; 0 <= level ? _i <= level : _i >= level; 0 <= level ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), function(str, l) {
      return str + " ";
    }, "");
  };

  getRootFrame = function(tagStack) {
    if (tagStack.parent == null) {
      return tagStack;
    } else {
      return getRootFrame(tagStack.parent);
    }
  };

  attrStr = function(attr) {
    var str;
    if (attr == null) {
      return "";
    } else {
      str = _.map(attr, function(v, k) {
        return k + ":'" + v + "'";
      }).join(", ");
      return " (" + str + ")";
    }
  };

  textStr = function(text) {
    if (text == null) {
      return "";
    } else {
      return " \"" + text + "\"";
    }
  };

  printTagStack = function(tagStack) {
    var printFrame;
    printFrame = function(frame, level) {
      var str;
      str = indentation(level) + frame.me + attrStr(frame.attr) + textStr(frame.text);
      if (frame.nodes.length > 0) {
        str = str + " ->";
      }
      console.error(str);
      return _.map(frame.nodes, function(f) {
        return printFrame(f, level + 1);
      });
    };
    return printFrame(getRootFrame(tagStack), 0);
  };


  /* unwrapFunctionToString()
   * purpose: convert function into string that can
   *          be sent over to client side
  #
   * in:      function
   * out:     string with code within the function
   */

  unwrapFunctionToString = function(fn) {
    return _(fn.toString()).split('\n').initial().tail().map(_.trim).join("").replace(/^return\s/, "");
  };


  /* ensureMarkupArguments()
   * purpose: helper function to the markup() function that
   *          ensures that the arguments sent in to markup()
   *          is correct
   * in:      tag     - name of tag
   *          attr    - attribute object
   *          content - either a function or a string
   * out:     [tag, attr, f, text] - array of the correct arguments
   */

  ensureMarkupArguments = function(tag, attr, content) {
    var f, text;
    f = null;
    text = null;
    if (!_.isString(tag)) {
      throw "Tag must be a string";
    }
    if (_.isPlainObject(attr)) {
      attr = attr;
    } else if ((_.isString(attr) || _.isFunction(attr)) && _.isUndefined(content)) {
      content = attr;
      attr = null;
    } else if (_.isUndefined(attr)) {
      attr = null;
    } else {
      throw "In '" + tag + "' attributes must be plain objects and content must be string or function";
    }
    if (_.isFunction(content)) {
      f = content;
    } else if (_.isString(content)) {
      text = content;
    }
    return [tag, attr, f, text];
  };


  /* markup()
   * purpose: represents a node in the html tree
   * in:      intag - the name of the tag to represent
   *          inattr - the attributes to go with the tag (plain object)
   *          incontent - the content to be wrapped by the tag
   * out:     the wrapper object, which contains functions that
   *          can be executed upon the tag
   */

  markup = function(tagStack, registeredFunctions, intag, inattr, incontent) {
    var attr, f, frame, tag, text, _ref;
    _ref = ensureMarkupArguments(intag, inattr, incontent), tag = _ref[0], attr = _ref[1], f = _ref[2], text = _ref[3];
    frame = {
      parent: tagStack,
      me: tag,
      attr: attr,
      text: text,
      nodes: []
    };
    if (tagStack != null) {
      tagStack.nodes.push(frame);
    }
    tagStack = frame;
    return (function(tag, attr, f, text) {
      var all, build, children, outer, tagfn, wrapper;
      children = [];
      build = null;

      /* tagfn()
       * purpose: it's called whenever a tag is executed, for instance
       *          @body or @tag('mytag'). the arguments is passed on
       *          to the markup() function, and the result of the
       *          markup() function is pushed on to the children array
       * in:      args... - any arguments that the markup() function
       *          would allow
       * out:     the current wrapper
       */
      tagfn = function() {
        var args, child;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        child = markup.apply(null, [tagStack, registeredFunctions].concat(__slice.call(args)));
        children.push(child);
        return child;
      };
      all = _.reduce(elements, function(obj, name) {
        obj[name] = _.bind(tagfn, null, name);
        return obj;
      }, {});
      wrapper = {

        /* apply()
         * purpose: enables the generator to be extended with
         *          predefined functions. the result will be mixed in
         *          on the same level as other siblings
         * in:      f - function that should be mixed in
         *          args... - any arguments that the function takes
         * out:     unknown
         */
        apply: function() {
          var args, f;
          f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (f == null) {
            console.error("Warning, tried to apply subnodes in tag stack:");
            return printTagStack(tagStack);
          } else {
            return _.bind.apply(_, [f, wrapper].concat(__slice.call(args)))();
          }
        },
        register: function(name, f) {
          if (_.isObject(name)) {
            return _.assign(registeredFunctions, name);
          } else if (_.isArray(name)) {
            return _.reduce(name, function(registered, newfn) {
              _.assign(registered, newfn);
              return registered;
            }, registeredFunctions);
          } else if (_.isString(name) && _.isFunction(f)) {
            registeredFunctions[name] = f;
            return wrapper[name] = _.bind(f, wrapper);
          } else {
            throw "@register either takes an object, array or a string and a function";
          }
        },

        /* tag()
         * purpose: enables the programmer to use an arbitrary tag
         *          by passing the first parameter tag as the name
         *          of the tag. for more info look at tagfn()
         */
        tag: tagfn,

        /* text()
         * purpose: allows user to insert any string within the tag
         * in:      text - the string to be inserted
         * out:     unknown
         */
        text: function(text) {
          return children.push({
            "eval": function() {
              return text;
            }
          });
        },

        /* doctype()
         * purpose: be able to set doc type
         * in:      attr - the string to accompany the doctype tag
         *          for simplicity, this defaults to "html" as of
         *          html5 standard
         * out:     unknown
         */
        doctype: function(attr) {
          return children.push({
            "eval": function() {
              if (_.isUndefined(attr)) {
                attr = "html";
              }
              return "<!DOCTYPE " + attr + ">";
            }
          });
        },

        /* script()
         * purpose: allows the user to define a script tag. this is
         *          an exception to the other default tags because
         *          it can take a function as an argument. the function
         *          will be stringified, unwrapped and sent to the
         *          client as a string within the script tag
         * in:      attr - any tag attributes
         *          content - function that will be stringified and unwrapped
         *          and sent to the client within the script tag or string
         *          that will be sent within the script tag
         * out:     unknown
         */
        script: function(scrattr, scrcontent) {
          if (_.isPlainObject(scrattr)) {
            scrattr = scrattr;
          } else if ((_.isFunction(scrattr) || _.isString(scrattr)) && _.isUndefined(scrcontent)) {
            scrcontent = scrattr;
            scrattr = null;
          } else {
            throw "Script tag attributes must be plain object";
          }
          if (_.isFunction(scrcontent)) {
            scrcontent = unwrapFunctionToString(scrcontent);
          } else if (_.isString(scrcontent)) {
            scrcontent = scrcontent;
          } else if (_.isUndefined(scrcontent)) {
            scrcontent = "";
          } else {
            throw "Script tag scrcontent must be either a string or a function";
          }
          return children.push({
            "eval": function() {
              var attribs;
              attribs = "";
              if (scrattr) {
                attribs = " " + _.map(scrattr, function(v, k) {
                  return k + "='" + v + "'";
                }).join(' ');
              }
              return "<script" + attribs + ">" + scrcontent + "</script>";
            }
          });
        },
        insert: function(f) {
          console.log("Trying to insert something into this:");
          console.log(tag, attr);
          return build(f);
        }
      };
      wrapper = _.assign(wrapper, all, registeredFunctions);
      build = function(f) {
        var ex;
        try {
          if (f != null) {
            return _.bind(f, wrapper)();
          }
        } catch (_error) {
          ex = _error;
          if (ex.message === "undefined is not a function") {
            console.error("Error in tag stack:");
            return printTagStack(tagStack);
          } else {
            throw ex;
          }
        }
      };
      outer = {

        /* before()
         * purpose: insert element in position before this tag
         */
        before: function(f) {
          throw "Not implemented";
        },

        /* before()
         * purpose: insert element in position after this tag
         */
        after: function(f) {
          throw "Not implemented";
        },

        /* insert()
         * purpose: insert elements into the tag, after the tag was created
         */
        insert: function(f) {
          return build(f);
        },
        "eval": function() {
          var attribs, inner;
          if (text != null) {
            inner = text;
          } else {
            inner = _.map(children, function(child) {
              return child["eval"]();
            }).join("");
          }
          attribs = "";
          if (attr != null) {
            attribs = " " + _.map(attr, function(v, k) {
              return k + "='" + v + "'";
            }).join(' ');
          }
          if (tag === "root_cempl_document") {
            return inner;
          } else if (tag != null) {
            return "<" + tag + attribs + ">" + inner + "</" + tag + ">";
          } else {
            return inner;
          }
        }
      };
      build(f);
      return outer;
    })(tag, attr, f, text);
  };

  module.exports = function(f) {
    return markup(null, {}, 'root_cempl_document', f);
  };

}).call(this);
